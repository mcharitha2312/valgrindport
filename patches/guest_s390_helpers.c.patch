diff --git a/VEX/priv/guest_s390_helpers.c b/VEX/priv/guest_s390_helpers.c
old mode 100644
new mode 100755
index 94d0a242d..4ba505c50
--- a/VEX/priv/guest_s390_helpers.c
+++ b/VEX/priv/guest_s390_helpers.c
@@ -260,10 +260,9 @@ VexGuestLayout s390xGuest_layout = {
 /*--- Dirty helper for EXecute                             ---*/
 /*------------------------------------------------------------*/
 void
-s390x_dirtyhelper_EX(ULong torun, Addr64 addr)
+s390x_dirtyhelper_EX(ULong torun)
 {
    last_execute_target = torun;
-   guest_IA_rel_base = addr;
 }
 
 
@@ -276,9 +275,9 @@ s390x_dirtyhelper_STCK(ULong *addr)
 {
    UInt cc;
 
-   asm volatile("stck %0\n"
-                "ipm %1\n"
-                "srl %1,28\n"
+   asm volatile(" stck %0\n"
+                " ipm %1\n"
+                " srl %1,28\n"
                 : "+Q" (*addr), "=d" (cc) : : "cc");
    return cc;
 }
@@ -288,9 +287,9 @@ s390x_dirtyhelper_STCKE(ULong *addr)
 {
    UInt cc;
 
-   asm volatile("stcke %0\n"
-                "ipm %1\n"
-                "srl %1,28\n"
+   asm volatile(" stcke %0\n"
+                " ipm %1\n"
+                " srl %1,28\n"
                 : "+Q" (*addr), "=d" (cc) : : "cc");
    return cc;
 }
@@ -299,9 +298,10 @@ ULong s390x_dirtyhelper_STCKF(ULong *addr)
 {
    UInt cc;
 
-   asm volatile(".insn s,0xb27c0000,%0\n"
-                "ipm %1\n"
-                "srl %1,28\n"
+   //asm volatile(".insn s,0xb27c0000,%0\n"
+   asm volatile(" stckf %0\n"
+                " ipm %1\n"
+                " srl %1,28\n"
                 : "+Q" (*addr), "=d" (cc) : : "cc");
    return cc;
 }
@@ -311,6 +311,122 @@ ULong s390x_dirtyhelper_STCKF(ULong *addr) {return 3;}
 ULong s390x_dirtyhelper_STCKE(ULong *addr) {return 3;}
 #endif /* VGA_s390x */
 
+/*------------------------------------------------------------*/
+/*--- Dirty helper for Store Facility instruction          ---*/
+/*------------------------------------------------------------*/
+#if defined(VGA_s390x)
+
+static ULong
+s390_stfle_range(UInt lo, UInt hi)
+{
+   return ((1UL << (hi + 1 - lo)) - 1) << (63 - (hi % 64));
+}
+
+ULong
+s390x_dirtyhelper_STFLE(VexGuestS390XState *guest_state, ULong *addr)
+{
+   ULong hoststfle[S390_NUM_FACILITY_DW], cc, num_dw, i;
+   register ULong reg0 asm("0") = guest_state->guest_r0 & 0xF;  /* r0[56:63] */
+
+   /* Restrict to facilities that we know about and that we assume to be
+      compatible with Valgrind.  Of course, in this way we may reject features
+      that Valgrind is not really involved in (and thus would be compatible
+      with), but quering for such features doesn't seem like a typical use
+      case. */
+   ULong accepted_facility[S390_NUM_FACILITY_DW] = {
+      /* ===  0 .. 63  === */
+      (s390_stfle_range(0, 16)
+       /* 17: message-security-assist, not supported */
+       | s390_stfle_range(18, 19)
+       /* 20: HFP-multiply-and-add/subtract, not supported */
+       | s390_stfle_range(21, 22)
+       /* 23: HFP-unnormalized-extension, not supported */
+       | s390_stfle_range(24, 25)
+       /* 26: parsing-enhancement, not supported */
+       | s390_stfle_range(27, 28)
+       /* 29: unassigned */
+       | s390_stfle_range(30, 30)
+       /* 31: extract-CPU-time, not supported */
+       | s390_stfle_range(32, 41)
+       /* 42-43: DFP, not fully supported */
+       /* 44: PFPO, not fully supported */
+       | s390_stfle_range(45, 47)
+       /* 48: DFP zoned-conversion, not supported */
+       /* 49: includes PPA, not supported */
+       /* 50: constrained transactional-execution, not supported */
+       | s390_stfle_range(51, 55)
+       /* 56: unassigned */
+       /* 57: MSA5, not supported */
+       | s390_stfle_range(58, 63)),
+
+      /* ===  64 .. 127  === */
+      (s390_stfle_range(64, 72)
+       /* 73: transactional-execution, not supported */
+       | s390_stfle_range(74, 75)
+       /* 76: MSA3, not supported */
+       /* 77: MSA4, not supported */
+       | s390_stfle_range(78, 78)
+       /* 80: DFP packed-conversion, not supported */
+       /* 81: PPA-in-order, not supported */
+       | s390_stfle_range(82, 82)
+       /* 83-127: unassigned */ ),
+
+      /* ===  128 .. 191  === */
+      (s390_stfle_range(128, 131)
+       /* 132: unassigned */
+       /* 133: guarded-storage, not supported */
+       /* 134: vector packed decimal, not supported */
+       | s390_stfle_range(135, 135)
+       /* 136: unassigned */
+       /* 137: unassigned */
+       | s390_stfle_range(138, 142)
+       /* 143: unassigned */
+       | s390_stfle_range(144, 145)
+       /* 146: MSA8, not supported */
+       | s390_stfle_range(147, 149)
+       /* 150: unassigned */
+       /* 151: DEFLATE-conversion, not supported */
+       /* 152: vector packed decimal enhancement, not supported */
+       /* 153: unassigned */
+       /* 154: unassigned */
+       /* 155: MSA9, not supported */
+       | s390_stfle_range(156, 156)
+       /* 157-167: unassigned */
+       | s390_stfle_range(168, 168)
+       /* 168-191: unassigned */ ),
+   };
+
+   /* We cannot store more than S390_NUM_FACILITY_DW
+      (and it makes not much sense to do so anyhow) */
+   if (reg0 > S390_NUM_FACILITY_DW - 1)
+      reg0 = S390_NUM_FACILITY_DW - 1;
+
+   num_dw = reg0 + 1;  /* number of double words written */
+
+   //asm volatile(" .insn s,0xb2b00000,%0\n"   /* stfle */
+   asm volatile(" stfle %0\n"   /* stfle */
+                " ipm    %2\n"
+                " srl    %2,28\n"
+                : "=m" (hoststfle), "+d"(reg0), "=d"(cc) : : "cc", "memory");
+
+   /* Update guest register 0  with what STFLE set r0 to */
+   guest_state->guest_r0 = reg0;
+
+   /* VM facilities = host facilities, filtered by acceptance */
+   for (i = 0; i < num_dw; ++i)
+      addr[i] = hoststfle[i] & accepted_facility[i];
+
+   return cc;
+}
+
+#else
+
+ULong
+s390x_dirtyhelper_STFLE(VexGuestS390XState *guest_state, ULong *addr)
+{
+   return 3;
+}
+#endif /* VGA_s390x */
 
 /*------------------------------------------------------------*/
 /*--- Dirty helper for the "convert unicode" insn family.  ---*/
@@ -450,7 +566,7 @@ s390_do_cu24(UInt srcval, UInt low_surrogate)
 
    srcval &= 0xffff;
 
-   if ((srcval <= 0xd7ff) ||
+   if ((srcval >= 0x0000 && srcval <= 0xd7ff) ||
        (srcval >= 0xdc00 && srcval <= 0xffff)) {
       retval = srcval;
    } else {
@@ -797,7 +913,7 @@ s390_do_cvb(ULong decimal)
    UInt binary;
 
    __asm__ volatile (
-        "cvb %[result],%[input]\n\t"
+        " cvb %[result],%[input]\n\t"
           : [result] "=d"(binary)
           : [input] "R"(decimal)
    );
@@ -821,7 +937,7 @@ s390_do_cvd(ULong binary_in)
    ULong decimal;
 
    __asm__ volatile (
-        "cvd %[input],%[result]\n\t"
+        " cvd %[input],%[result]\n\t"
           : [result] "=m"(decimal)
           : [input] "d"(binary)
    );
@@ -842,7 +958,8 @@ s390_do_ecag(ULong op2addr)
 {
    ULong result;
 
-   __asm__ volatile(".insn rsy,0xEB000000004C,%[out],0,0(%[in])\n\t"
+   //__asm__ volatile(".insn rsy,0xEB000000004C,%[out],0,0(%[in])\n\t"
+   __asm__ volatile(" ecag %[out],0,0(%[in])\n\t"
                     : [out] "=d"(result)
                     : [in] "d"(op2addr));
    return result;
@@ -907,8 +1024,8 @@ decode_bfp_rounding_mode(UInt irrm)
 #define S390_CC_FOR_BINARY(opcode,cc_dep1,cc_dep2) \
 ({ \
    __asm__ volatile ( \
-        opcode " %[op1],%[op2]\n\t" \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [op1] "+d"(cc_dep1) \
+        " " opcode " %[op1],%[op2]\n\t" \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [op1] "+d"(cc_dep1) \
                                    : [op2] "d"(cc_dep2) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
@@ -917,8 +1034,8 @@ decode_bfp_rounding_mode(UInt irrm)
 #define S390_CC_FOR_TERNARY(opcode,cc_dep1,cc_dep2) \
 ({ \
    __asm__ volatile ( \
-        opcode ",%[op1],%[op1],%[op2],0\n\t" \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [op1] "+d"(cc_dep1) \
+        " " opcode " %[op1],%[op1],%[op2]\n\t" \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [op1] "+d"(cc_dep1) \
                                    : [op2] "d"(cc_dep2) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
@@ -931,9 +1048,9 @@ decode_bfp_rounding_mode(UInt irrm)
    cc_dep2 = cc_dep2 ^ cc_ndep; \
    ULong tmp = 1; \
    __asm__ volatile ( \
-        "sr %[tmp],%[op3]\n\t" /* borrow to cc */ \
-        opcode " %[op1],%[op2]\n\t" /* then redo the op */\
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [op1] "+&d"(cc_dep1), \
+        " sr %[tmp],%[op3]\n\t" /* borrow to cc */ \
+        " " opcode " %[op1],%[op2]\n\t" /* then redo the op */\
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [op1] "+&d"(cc_dep1), \
                                      [tmp] "+&d"(tmp) \
                                    : [op2] "d"(cc_dep2), [op3] "d"(cc_ndep) \
                                    : "cc");\
@@ -947,10 +1064,10 @@ decode_bfp_rounding_mode(UInt irrm)
    cc_dep2 = cc_dep2 ^ cc_ndep; \
    ULong tmp; \
    __asm__ volatile ( \
-        "lgfr %[tmp],%[op3]\n\t" /* first load cc_ndep */ \
-        "aghi %[tmp],0\n\t" /* and convert it into a cc */ \
-        opcode " %[op1],%[op2]\n\t" /* then redo the op */\
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [op1] "+&d"(cc_dep1), \
+        " lgfr %[tmp],%[op3]\n\t" /* first load cc_ndep */ \
+        " aghi %[tmp],0\n\t" /* and convert it into a cc */ \
+        " "  opcode " %[op1],%[op2]\n\t" /* then redo the op */\
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [op1] "+&d"(cc_dep1), \
                                      [tmp] "=&d"(tmp) \
                                    : [op2] "d"(cc_dep2), [op3] "d"(cc_ndep) \
                                    : "cc");\
@@ -963,8 +1080,8 @@ decode_bfp_rounding_mode(UInt irrm)
    union s390x_F64 op = { .i = cc_dep1 }; \
    Double tmp; \
    __asm__ volatile ( \
-        opcode " %[tmp],%[op]\n\t" \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=f"(tmp) \
+       " " opcode " %[tmp],%[op]\n\t" \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=f"(tmp) \
                                    : [op]  "f"(op.f) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
@@ -975,8 +1092,8 @@ decode_bfp_rounding_mode(UInt irrm)
    union s390x_F128 op = { .i = { hi, lo } }; \
    Float128 tmp; \
    __asm__ volatile ( \
-        "ltxbr %[tmp],%[op]\n\t" \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=f"(tmp) \
+        " ltxbr %[tmp],%[op]\n\t" \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=f"(tmp) \
                                    : [op]  "f"(op.f) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
@@ -987,8 +1104,8 @@ decode_bfp_rounding_mode(UInt irrm)
    union s390x_F64 op = { .i = cc_dep1 }; \
    ULong tmp; \
    __asm__ volatile ( \
-        opcode " %[tmp]," #rounding_mode ",%[op]\n\t" \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=d"(tmp) \
+        " " opcode " %[tmp]," #rounding_mode ",%[op]\n\t" \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=d"(tmp) \
                                    : [op]  "f"(op.f) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
@@ -1021,8 +1138,8 @@ decode_bfp_rounding_mode(UInt irrm)
    union s390x_F64 op = { .i = cc_dep1 }; \
    ULong tmp; \
    __asm__ volatile ( \
-        opcode ",%[tmp],%[op]," #rounding_mode ",0\n\t" \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=d"(tmp) \
+       " "  opcode " %[tmp],%[op]," #rounding_mode ",0\n\t" \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=d"(tmp) \
                                    : [op]  "f"(op.f) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
@@ -1055,8 +1172,8 @@ decode_bfp_rounding_mode(UInt irrm)
    union s390x_F128 op = { .i = { hi, lo } }; \
    ULong tmp; \
    __asm__ volatile ( \
-        opcode " %[tmp]," #rounding_mode ",%[op]\n\t" \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=d"(tmp) \
+       " " opcode " %[tmp]," #rounding_mode ",%[op]\n\t" \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=d"(tmp) \
                                    : [op] "f"(op.f) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
@@ -1092,8 +1209,8 @@ decode_bfp_rounding_mode(UInt irrm)
    union s390x_F128 op = { .i = { hi, lo } }; \
    ULong tmp; \
    __asm__ volatile ( \
-        opcode ",%[tmp],%[op]," #rounding_mode ",0\n\t" \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=d"(tmp) \
+        " " opcode " %[tmp],%[op]," #rounding_mode ",0\n\t" \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=d"(tmp) \
                                    : [op] "f"(op.f) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
@@ -1113,10 +1230,10 @@ decode_bfp_rounding_mode(UInt irrm)
       cc = S390_CC_FOR_BFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,5); \
       break;                                                          \
    case S390_BFP_ROUND_POSINF:                                        \
-      cc = S390_CC_FOR_BFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,6); \
+      cc = S390_CC_FOR_BFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,9); \
       break;                                                          \
    case S390_BFP_ROUND_NEGINF:                                        \
-      cc = S390_CC_FOR_BFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,7); \
+      cc = S390_CC_FOR_BFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,8); \
       break;                                                          \
    default:                                                           \
       vpanic("unexpected bfp rounding mode");                         \
@@ -1128,8 +1245,8 @@ decode_bfp_rounding_mode(UInt irrm)
 ({ \
    union s390x_F64 val = { .i = cc_dep1 }; \
    __asm__ volatile ( \
-        opcode " %[value],0(%[class])\n\t" \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw) \
+        " " opcode " %[value],0(%[class])\n\t" \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw) \
                                    : [value] "f"(val.f), \
                                      [class] "a"(cc_dep2)  \
                                    : "cc");\
@@ -1143,8 +1260,8 @@ decode_bfp_rounding_mode(UInt irrm)
    cc_dep2 = cc_dep2 ^ cc_ndep; \
    union s390x_F128 val = { .i = { cc_dep1, cc_dep2 } }; \
    __asm__ volatile ( \
-        "tcxb %[value],0(%[class])\n\t" \
-        "ipm  %[psw]\n\t"          : [psw] "=d"(psw) \
+        " tcxb %[value],0(%[class])\n\t" \
+        " ipm  %[psw]\n\t"          : [psw] "=d"(psw) \
                                    : [value] "f"(val.f), [class] "a"(cc_ndep) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
@@ -1174,26 +1291,26 @@ decode_dfp_rounding_mode(UInt irrm)
    }
    vpanic("decode_dfp_rounding_mode");
 }
-
+//.insn rre, 0xb3d60000
 #define S390_CC_FOR_DFP_RESULT(cc_dep1) \
 ({ \
    union s390x_F64 op = { .i = cc_dep1 }; \
    Double tmp; \
    __asm__ volatile ( \
-        ".insn rre, 0xb3d60000,%[tmp],%[op]\n\t"            /* LTDTR */ \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=f"(tmp) \
+        " ltdtr %[tmp],%[op]\n\t"            /* LTDTR */ \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=f"(tmp) \
                                    : [op]  "f"(op.f) \
                                    : "cc");\
    psw >> 28;   /* cc */ \
 })
-
+  //".insn rre, 0xb3de0000,%[tmp],%[op]\n\t"           /* LTXTR */  
 #define S390_CC_FOR_DFP128_RESULT(hi,lo) \
 ({ \
    union s390x_F128 op = { .i = { hi, lo } }; \
    Float128 tmp; \
    __asm__ volatile ( \
-        ".insn rre, 0xb3de0000,%[tmp],%[op]\n\t"           /* LTXTR */  \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
+        " ltxtr %[tmp],%[op]\n\t"           /* LTXTR */  \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
                                    : [op] "f"(op.f)                     \
                                    : "cc");                             \
    psw >> 28;   /* cc */                                                \
@@ -1203,8 +1320,8 @@ decode_dfp_rounding_mode(UInt irrm)
 ({                                                                      \
    union s390x_F64 val = { .i = cc_dep1 };                              \
    __asm__ volatile (                                                   \
-        opcode ",%[value],0(%[class])\n\t"                              \
-        "ipm %[psw]\n\t"           : [psw] "=d"(psw)                    \
+        " " opcode " %[value],0(%[class])\n\t"                              \
+        " ipm %[psw]\n\t"           : [psw] "=d"(psw)                    \
                                    : [value] "f"(val.f),                \
                                      [class] "a"(cc_dep2)               \
                                    : "cc");                             \
@@ -1218,21 +1335,74 @@ decode_dfp_rounding_mode(UInt irrm)
    cc_dep2 = cc_dep2 ^ cc_ndep;                                         \
    union s390x_F128 val = { .i = { cc_dep1, cc_dep2 } };                \
    __asm__ volatile (                                                   \
-        opcode ",%[value],0(%[class])\n\t"                              \
-        "ipm  %[psw]\n\t"          : [psw] "=d"(psw)                    \
+        " " opcode " %[value],0(%[class])\n\t"                              \
+        " ipm  %[psw]\n\t"          : [psw] "=d"(psw)                    \
                                    : [value] "f"(val.f),                \
                                      [class] "a"(cc_ndep)               \
                                    : "cc");                             \
    psw >> 28;   /* cc */                                                \
 })
 
+#define S390_CC_FOR_DFP_CONVERT_AUX_ZOS(opcode,cc_dep1,rounding_mode)       \
+   ({                                                                   \
+      union s390x_F64 op = { .i = cc_dep1 };                            \
+      Double tmp;                                                       \
+      __asm__ volatile (                                                \
+         " " opcode " %[tmp]," #rounding_mode ",0\n\t"                \
+         " ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
+                                   : [op] "f"(op.f)                     \
+         : "cc");                                                       \
+      psw >> 28;   /* cc */                                             \
+   })
+
+#define S390_CC_FOR_DFP_CONVERT_ZOS(opcode,cc_dep1,cc_dep2)                 \
+   ({                                                                   \
+      UInt cc;                                                          \
+      switch (decode_dfp_rounding_mode(cc_dep2)) {                      \
+      case S390_DFP_ROUND_NEAREST_TIE_AWAY_0_1:                         \
+      case S390_DFP_ROUND_NEAREST_TIE_AWAY_0_12:                        \
+         cc = S390_CC_FOR_DFP_CONVERT_AUX_ZOS(opcode,cc_dep1,1);            \
+         break;                                                         \
+      case S390_DFP_ROUND_PREPARE_SHORT_3:                              \
+      case S390_DFP_ROUND_PREPARE_SHORT_15:                             \
+         cc = S390_CC_FOR_DFP_CONVERT_AUX_ZOS(opcode,cc_dep1,3);            \
+         break;                                                         \
+      case S390_DFP_ROUND_NEAREST_EVEN_4:                               \
+      case S390_DFP_ROUND_NEAREST_EVEN_8:                               \
+         cc = S390_CC_FOR_DFP_CONVERT_AUX_ZOS(opcode,cc_dep1,4);            \
+         break;                                                         \
+      case S390_DFP_ROUND_ZERO_5:                                       \
+      case S390_DFP_ROUND_ZERO_9:                                       \
+         cc = S390_CC_FOR_DFP_CONVERT_AUX_ZOS(opcode,cc_dep1,5);            \
+         break;                                                         \
+      case S390_DFP_ROUND_POSINF_6:                                     \
+      case S390_DFP_ROUND_POSINF_10:                                    \
+         cc = S390_CC_FOR_DFP_CONVERT_AUX_ZOS(opcode,cc_dep1,6);            \
+         break;                                                         \
+      case S390_DFP_ROUND_NEGINF_7:                                     \
+      case S390_DFP_ROUND_NEGINF_11:                                    \
+	 cc = S390_CC_FOR_DFP_CONVERT_AUX_ZOS(opcode,cc_dep1,7);            \
+         break;                                                         \
+      case S390_DFP_ROUND_NEAREST_TIE_TOWARD_0:                         \
+         cc = S390_CC_FOR_DFP_CONVERT_AUX_ZOS(opcode,cc_dep1,13);           \
+         break;                                                         \
+      case S390_DFP_ROUND_AWAY_0:                                       \
+         cc = S390_CC_FOR_DFP_CONVERT_AUX_ZOS(opcode,cc_dep1,14);           \
+         break;                                                         \
+      default:                                                          \
+         vpanic("unexpected dfp rounding mode");                        \
+      }                                                                 \
+      cc;                                                               \
+   })
+
+
 #define S390_CC_FOR_DFP_CONVERT_AUX(opcode,cc_dep1,rounding_mode)       \
    ({                                                                   \
       union s390x_F64 op = { .i = cc_dep1 };                            \
       Double tmp;                                                       \
       __asm__ volatile (                                                \
-         opcode ",%[tmp],%[op]," #rounding_mode ",0\n\t"                \
-         "ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
+         " " opcode " %[tmp],%[op]," #rounding_mode ",0\n\t"                \
+         " ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
                                    : [op] "f"(op.f)                     \
          : "cc");                                                       \
       psw >> 28;   /* cc */                                             \
@@ -1283,8 +1453,8 @@ decode_dfp_rounding_mode(UInt irrm)
       union s390x_F64 op = { .i = cc_dep1 };                            \
       Double tmp;                                                       \
       __asm__ volatile (                                                \
-         opcode ",%[tmp],%[op]," #rounding_mode ",0\n\t"                \
-         "ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
+         " " opcode " %[tmp],%[op]," #rounding_mode ",0\n\t"                \
+         " ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
                                    : [op] "f"(op.f)                     \
                                    : "cc");                             \
       psw >> 28;   /* cc */                                             \
@@ -1335,13 +1505,68 @@ decode_dfp_rounding_mode(UInt irrm)
       union s390x_F128 op = { .i = { hi, lo } };                        \
       Double tmp;                                                       \
       __asm__ volatile (                                                \
-         opcode ",%[tmp],%[op]," #rounding_mode ",0\n\t"                \
-         "ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
+         " " opcode " %[tmp],%[op]," #rounding_mode ",0\n\t"                \
+         " ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
                                    : [op] "f"(op.f)                     \
                                    : "cc");                             \
       psw >> 28;   /* cc */                                             \
    })
 
+#define S390_CC_FOR_DFP128_CONVERT_AUX_ZOS(opcode,hi,lo,rounding_mode)      \
+   ({                                                                   \
+      union s390x_F128 op = { .i = { hi, lo } };                        \
+      Double tmp;                                                       \
+      __asm__ volatile (                                                \
+         " " opcode " %[tmp],%[op]," #rounding_mode "\n\t"                \
+         " ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
+                                   : [op] "f"(op.f)                     \
+                                   : "cc");                             \
+      psw >> 28;   /* cc */                                             \
+   })
+
+#define S390_CC_FOR_DFP128_CONVERT_ZOS(opcode,cc_dep1,cc_dep2,cc_ndep)       \
+   ({                                                                    \
+      UInt cc;                                                           \
+      /* Recover the original DEP2 value. See comment near               \
+         s390_cc_thunk_put3 for rationale. */                            \
+      cc_dep2 = cc_dep2 ^ cc_ndep;                                       \
+      switch (decode_dfp_rounding_mode(cc_ndep)) {                       \
+      case S390_DFP_ROUND_NEAREST_TIE_AWAY_0_1:                          \
+      case S390_DFP_ROUND_NEAREST_TIE_AWAY_0_12:                         \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX_ZOS(opcode,cc_dep1,cc_dep2,1);  \
+         break;                                                          \
+      case S390_DFP_ROUND_PREPARE_SHORT_3:                               \
+      case S390_DFP_ROUND_PREPARE_SHORT_15:                              \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX_ZOS(opcode,cc_dep1,cc_dep2,0);  \
+         break;                                                          \
+      case S390_DFP_ROUND_NEAREST_EVEN_4:                                \
+      case S390_DFP_ROUND_NEAREST_EVEN_8:                                \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX_ZOS(opcode,cc_dep1,cc_dep2,4);  \
+         break;                                                          \
+      case S390_DFP_ROUND_ZERO_5:                                        \
+      case S390_DFP_ROUND_ZERO_9:                                        \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX_ZOS(opcode,cc_dep1,cc_dep2,5);  \
+         break;                                                          \
+      case S390_DFP_ROUND_POSINF_6:                                      \
+      case S390_DFP_ROUND_POSINF_10:                                     \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX_ZOS(opcode,cc_dep1,cc_dep2,9);  \
+         break;                                                          \
+      case S390_DFP_ROUND_NEGINF_7:                                      \
+      case S390_DFP_ROUND_NEGINF_11:                                     \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX_ZOS(opcode,cc_dep1,cc_dep2,8);  \
+         break;                                                          \
+      case S390_DFP_ROUND_NEAREST_TIE_TOWARD_0:                          \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX_ZOS(opcode,cc_dep1,cc_dep2,13); \
+         break;                                                          \
+      case S390_DFP_ROUND_AWAY_0:                                        \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX_ZOS(opcode,cc_dep1,cc_dep2,12); \
+         break;                                                          \
+      default:                                                           \
+         vpanic("unexpected dfp rounding mode");                         \
+      }                                                                  \
+      cc;                                                                \
+  })
+
 #define S390_CC_FOR_DFP128_CONVERT(opcode,cc_dep1,cc_dep2,cc_ndep)       \
    ({                                                                    \
       UInt cc;                                                           \
@@ -1355,7 +1580,7 @@ decode_dfp_rounding_mode(UInt irrm)
          break;                                                          \
       case S390_DFP_ROUND_PREPARE_SHORT_3:                               \
       case S390_DFP_ROUND_PREPARE_SHORT_15:                              \
-         cc = S390_CC_FOR_DFP128_CONVERT_AUX(opcode,cc_dep1,cc_dep2,3);  \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX(opcode,cc_dep1,cc_dep2,0);  \
          break;                                                          \
       case S390_DFP_ROUND_NEAREST_EVEN_4:                                \
       case S390_DFP_ROUND_NEAREST_EVEN_8:                                \
@@ -1367,31 +1592,31 @@ decode_dfp_rounding_mode(UInt irrm)
          break;                                                          \
       case S390_DFP_ROUND_POSINF_6:                                      \
       case S390_DFP_ROUND_POSINF_10:                                     \
-         cc = S390_CC_FOR_DFP128_CONVERT_AUX(opcode,cc_dep1,cc_dep2,6);  \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX(opcode,cc_dep1,cc_dep2,9);  \
          break;                                                          \
       case S390_DFP_ROUND_NEGINF_7:                                      \
       case S390_DFP_ROUND_NEGINF_11:                                     \
-         cc = S390_CC_FOR_DFP128_CONVERT_AUX(opcode,cc_dep1,cc_dep2,7);  \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX(opcode,cc_dep1,cc_dep2,8);  \
          break;                                                          \
       case S390_DFP_ROUND_NEAREST_TIE_TOWARD_0:                          \
          cc = S390_CC_FOR_DFP128_CONVERT_AUX(opcode,cc_dep1,cc_dep2,13); \
          break;                                                          \
       case S390_DFP_ROUND_AWAY_0:                                        \
-         cc = S390_CC_FOR_DFP128_CONVERT_AUX(opcode,cc_dep1,cc_dep2,14); \
+         cc = S390_CC_FOR_DFP128_CONVERT_AUX(opcode,cc_dep1,cc_dep2,12); \
          break;                                                          \
       default:                                                           \
          vpanic("unexpected dfp rounding mode");                         \
       }                                                                  \
-      cc;                                                                \
-   })
+      cc; \
+})
 
 #define S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,hi,lo,rounding_mode)     \
    ({                                                                   \
       union s390x_F128 op = { .i = { hi, lo } };                        \
       Double tmp;                                                       \
       __asm__ volatile (                                                \
-         opcode ",%[tmp],%[op]," #rounding_mode ",0\n\t"                \
-         "ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
+         " " opcode " %[tmp],%[op]," #rounding_mode ",0\n\t"                \
+         " ipm %[psw]\n\t"          : [psw] "=d"(psw), [tmp] "=f"(tmp)   \
                                    : [op] "f"(op.f)                     \
                                    : "cc");                             \
       psw >> 28;   /* cc */                                             \
@@ -1410,7 +1635,7 @@ decode_dfp_rounding_mode(UInt irrm)
          break;                                                           \
       case S390_DFP_ROUND_PREPARE_SHORT_3:                                \
       case S390_DFP_ROUND_PREPARE_SHORT_15:                               \
-         cc = S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,3);  \
+         cc = S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,0);  \
          break;                                                           \
       case S390_DFP_ROUND_NEAREST_EVEN_4:                                 \
       case S390_DFP_ROUND_NEAREST_EVEN_8:                                 \
@@ -1422,17 +1647,17 @@ decode_dfp_rounding_mode(UInt irrm)
          break;                                                           \
       case S390_DFP_ROUND_POSINF_6:                                       \
       case S390_DFP_ROUND_POSINF_10:                                      \
-         cc = S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,6);  \
+         cc = S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,9);  \
          break;                                                           \
       case S390_DFP_ROUND_NEGINF_7:                                       \
       case S390_DFP_ROUND_NEGINF_11:                                      \
-         cc = S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,7);  \
+         cc = S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,8);  \
          break;                                                           \
       case S390_DFP_ROUND_NEAREST_TIE_TOWARD_0:                           \
          cc = S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,13); \
          break;                                                           \
       case S390_DFP_ROUND_AWAY_0:                                         \
-         cc = S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,14); \
+         cc = S390_CC_FOR_DFP128_UCONVERT_AUX(opcode,cc_dep1,cc_dep2,12); \
          break;                                                           \
       default:                                                            \
          vpanic("unexpected dfp rounding mode");                          \
@@ -1454,10 +1679,10 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
    switch (cc_op) {
 
    case S390_CC_OP_BITWISE:
-      return S390_CC_FOR_BINARY("ogr", cc_dep1, (ULong)0);
+      return S390_CC_FOR_BINARY(" ogr", cc_dep1, (ULong)0);
 
    case S390_CC_OP_SIGNED_COMPARE:
-      return S390_CC_FOR_BINARY("cgr", cc_dep1, cc_dep2);
+      return S390_CC_FOR_BINARY(" cgr", cc_dep1, cc_dep2);
 
    case S390_CC_OP_UNSIGNED_COMPARE:
       return S390_CC_FOR_BINARY("clgr", cc_dep1, cc_dep2);
@@ -1466,10 +1691,10 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
       return S390_CC_FOR_BINARY("agr", cc_dep1, cc_dep2);
 
    case S390_CC_OP_SIGNED_ADD_32:
-      return S390_CC_FOR_BINARY("ar", cc_dep1, cc_dep2);
+      return S390_CC_FOR_BINARY(" ar", cc_dep1, cc_dep2);
 
    case S390_CC_OP_SIGNED_SUB_64:
-      return S390_CC_FOR_BINARY("sgr", cc_dep1, cc_dep2);
+      return S390_CC_FOR_BINARY(" sgr", cc_dep1, cc_dep2);
 
    case S390_CC_OP_SIGNED_SUB_32:
       return S390_CC_FOR_BINARY("sr", cc_dep1, cc_dep2);
@@ -1504,16 +1729,16 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
 
    case S390_CC_OP_LOAD_POSITIVE_32:
       __asm__ volatile (
-           "lpr  %[result],%[op]\n\t"
-           "ipm  %[psw]\n\t"         : [psw] "=d"(psw), [result] "=d"(cc_dep1)
+           " lpr  %[result],%[op]\n\t"
+           " ipm  %[psw]\n\t"         : [psw] "=d"(psw), [result] "=d"(cc_dep1)
                                      : [op] "d"(cc_dep1)
                                      : "cc");
       return psw >> 28;   /* cc */
 
    case S390_CC_OP_LOAD_POSITIVE_64:
       __asm__ volatile (
-           "lpgr %[result],%[op]\n\t"
-           "ipm  %[psw]\n\t"         : [psw] "=d"(psw), [result] "=d"(cc_dep1)
+           " lpgr %[result],%[op]\n\t"
+           " ipm  %[psw]\n\t"         : [psw] "=d"(psw), [result] "=d"(cc_dep1)
                                      : [op] "d"(cc_dep1)
                                      : "cc");
       return psw >> 28;   /* cc */
@@ -1524,10 +1749,10 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
       ULong pc;
 
       __asm__ volatile (
-           "bras %[pc],1f\n\t"            /* pc = address of next insn */
-           "tm %[value],0\n\t"            /* this is skipped, then EXecuted */
-           "1: ex %[mask],0(%[pc])\n\t"   /* EXecute TM after modifying mask */
-           "ipm %[psw]\n\t"             : [psw] "=d"(psw), [pc] "=&a"(pc)
+           " la %[pc],1f\n"             /* pc = address of next insn */
+           " tm %[value],0\n"            /* this is skipped, then EXecuted */
+           " ex %[mask],0(%[pc])\n\t"   /* EXecute TM after modifying mask */
+           " ipm %[psw]\n\t"             : [psw] "=d"(psw), [pc] "=&a"(pc)
                                         : [value] "Q"(value), [mask] "a"(mask)
                                         : "cc");
       return psw >> 28;   /* cc */
@@ -1539,10 +1764,10 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
       UInt value = cc_dep1;
 
       __asm__ volatile (
-           "lr   1,%[value]\n\t"
-           "lhi  2,0x10\n\t"
-           "ex   2,%[insn]\n\t"
-           "ipm  %[psw]\n\t"       : [psw] "=d"(psw)
+           " lr   1,%[value]\n"
+           " lhi  2,16\n\t"
+           " ex   2,%[insn]\n\t"
+           " ipm  %[psw]\n\t"       : [psw] "=d"(psw)
                                    : [value] "d"(value), [insn] "R"(insn)
                                    : "r1", "r2", "cc");
       return psw >> 28;   /* cc */
@@ -1550,8 +1775,8 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
 
    case S390_CC_OP_SHIFT_LEFT_32:
       __asm__ volatile (
-           "sla  %[op],0(%[amount])\n\t"
-           "ipm  %[psw]\n\t"            : [psw] "=d"(psw), [op] "+d"(cc_dep1)
+           " sla  %[op],0(%[amount])\n\t"
+           " ipm  %[psw]\n\t"            : [psw] "=d"(psw), [op] "+d"(cc_dep1)
                                         : [amount] "a"(cc_dep2)
                                         : "cc");
       return psw >> 28;   /* cc */
@@ -1561,10 +1786,10 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
       Int low  = (Int)(cc_dep1 & 0xFFFFFFFF);
 
       __asm__ volatile (
-           "lr   2,%[high]\n\t"
-           "lr   3,%[low]\n\t"
-           "slda 2,0(%[amount])\n\t"
-           "ipm %[psw]\n\t"             : [psw] "=d"(psw), [high] "+d"(high),
+           " lr   2,%[high]\n\t"
+           " lr   3,%[low]\n\t"
+           " slda 2,0(%[amount])\n\t"
+           " ipm %[psw]\n\t"             : [psw] "=d"(psw), [high] "+d"(high),
                                           [low] "+d"(low)
                                         : [amount] "a"(cc_dep2)
                                         : "cc", "r2", "r3");
@@ -1600,10 +1825,10 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
    }
 
    case S390_CC_OP_BFP_RESULT_32:
-      return S390_CC_FOR_BFP_RESULT("ltebr", cc_dep1);
+      return S390_CC_FOR_BFP_RESULT(" ltebr", cc_dep1);
 
    case S390_CC_OP_BFP_RESULT_64:
-      return S390_CC_FOR_BFP_RESULT("ltdbr", cc_dep1);
+      return S390_CC_FOR_BFP_RESULT(" ltdbr", cc_dep1);
 
    case S390_CC_OP_BFP_RESULT_128:
       return S390_CC_FOR_BFP128_RESULT(cc_dep1, cc_dep2);
@@ -1639,24 +1864,32 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
       return cc_dep1;
 
    case S390_CC_OP_BFP_32_TO_UINT_32:
-      return S390_CC_FOR_BFP_UCONVERT(".insn rrf,0xb39c0000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_BFP_UCONVERT(" clfebr", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_BFP_UCONVERT(".insn rrf,0xb39c0000", cc_dep1, cc_dep2);
 
    case S390_CC_OP_BFP_64_TO_UINT_32:
-      return S390_CC_FOR_BFP_UCONVERT(".insn rrf,0xb39d0000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_BFP_UCONVERT(" clfdbr", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_BFP_UCONVERT(".insn rrf,0xb39d0000", cc_dep1, cc_dep2);
 
    case S390_CC_OP_BFP_128_TO_UINT_32:
-      return S390_CC_FOR_BFP128_UCONVERT(".insn rrf,0xb39e0000", cc_dep1,
+      return S390_CC_FOR_BFP128_UCONVERT(" clfxbr", cc_dep1,
                                          cc_dep2, cc_ndep);
+      //return S390_CC_FOR_BFP128_UCONVERT(".insn rrf,0xb39e0000", cc_dep1,
+        //                                 cc_dep2, cc_ndep);
 
    case S390_CC_OP_BFP_32_TO_UINT_64:
-      return S390_CC_FOR_BFP_UCONVERT(".insn rrf,0xb3ac0000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_BFP_UCONVERT(" clgebr", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_BFP_UCONVERT(".insn rrf,0xb3ac0000", cc_dep1, cc_dep2);
 
    case S390_CC_OP_BFP_64_TO_UINT_64:
-      return S390_CC_FOR_BFP_UCONVERT(".insn rrf,0xb3ad0000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_BFP_UCONVERT(" clgdbr", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_BFP_UCONVERT(".insn rrf,0xb3ad0000", cc_dep1, cc_dep2);
 
    case S390_CC_OP_BFP_128_TO_UINT_64:
-      return S390_CC_FOR_BFP128_UCONVERT(".insn rrf,0xb3ae0000", cc_dep1,
+      return S390_CC_FOR_BFP128_UCONVERT(" clgxbr", cc_dep1,
                                          cc_dep2, cc_ndep);
+      //return S390_CC_FOR_BFP128_UCONVERT(".insn rrf,0xb3ae0000", cc_dep1,
+        //                                 cc_dep2, cc_ndep);
 
    case S390_CC_OP_DFP_RESULT_64:
       return S390_CC_FOR_DFP_RESULT(cc_dep1);
@@ -1665,59 +1898,80 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
       return S390_CC_FOR_DFP128_RESULT(cc_dep1, cc_dep2);
 
    case S390_CC_OP_DFP_TDC_32:  /* TDCET */
-      return S390_CC_FOR_DFP_TD(".insn rxe, 0xed0000000050", cc_dep1, cc_dep2);
+      return S390_CC_FOR_DFP_TD(" tdcet", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_DFP_TD(".insn rxe, 0xed0000000050", cc_dep1, cc_dep2);
 
    case S390_CC_OP_DFP_TDC_64:  /* TDCDT */
-      return S390_CC_FOR_DFP_TD(".insn rxe, 0xed0000000054", cc_dep1, cc_dep2);
+      return S390_CC_FOR_DFP_TD(" tdcdt", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_DFP_TD(".insn rxe, 0xed0000000054", cc_dep1, cc_dep2);
 
    case S390_CC_OP_DFP_TDC_128: /* TDCXT */
-      return S390_CC_FOR_DFP128_TD(".insn rxe, 0xed0000000058", cc_dep1,
+      return S390_CC_FOR_DFP128_TD(" tdcxt", cc_dep1,
                                    cc_dep2, cc_ndep);
+      //return S390_CC_FOR_DFP128_TD(".insn rxe, 0xed0000000058", cc_dep1,
+        //                           cc_dep2, cc_ndep);
 
    case S390_CC_OP_DFP_TDG_32:  /* TDGET */
-      return S390_CC_FOR_DFP_TD(".insn rxe, 0xed0000000051", cc_dep1, cc_dep2);
+      return S390_CC_FOR_DFP_TD(" tdget", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_DFP_TD(".insn rxe, 0xed0000000051", cc_dep1, cc_dep2);
 
    case S390_CC_OP_DFP_TDG_64:  /* TDGDT */
-      return S390_CC_FOR_DFP_TD(".insn rxe, 0xed0000000055", cc_dep1, cc_dep2);
+      return S390_CC_FOR_DFP_TD(" tdgdt", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_DFP_TD(".insn rxe, 0xed0000000055", cc_dep1, cc_dep2);
 
    case S390_CC_OP_DFP_TDG_128: /* TDGXT */
-      return S390_CC_FOR_DFP128_TD(".insn rxe, 0xed0000000059", cc_dep1,
-                                   cc_dep2, cc_ndep);
+      return S390_CC_FOR_DFP128_TD(" tdgxt", cc_dep1,
+		      cc_dep2, cc_ndep);
+      //return S390_CC_FOR_DFP128_TD(".insn rxe, 0xed0000000059", cc_dep1,
+        //                           cc_dep2, cc_ndep);
 
    case S390_CC_OP_DFP_64_TO_INT_32: /* CFDTR */
-      return S390_CC_FOR_DFP_CONVERT(".insn rrf,0xb9410000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_DFP_CONVERT(" cfdtr", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_DFP_CONVERT(".insn rrf,0xb9410000", cc_dep1, cc_dep2);
 
    case S390_CC_OP_DFP_128_TO_INT_32: /* CFXTR */
-      return S390_CC_FOR_DFP128_CONVERT(".insn rrf,0xb9490000", cc_dep1,
+      return S390_CC_FOR_DFP128_CONVERT(" cfxtr", cc_dep1,
                                         cc_dep2, cc_ndep);
+      //return S390_CC_FOR_DFP128_CONVERT(".insn rrf,0xb9490000", cc_dep1,
+        //                                cc_dep2, cc_ndep);
 
    case S390_CC_OP_DFP_64_TO_INT_64: /* CGDTR */
-      return S390_CC_FOR_DFP_CONVERT(".insn rrf,0xb3e10000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_DFP_CONVERT_ZOS("cgdtr", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_DFP_CONVERT(".insn rrf,0xb3e10000", cc_dep1, cc_dep2);
 
    case S390_CC_OP_DFP_128_TO_INT_64: /* CGXTR */
-      return S390_CC_FOR_DFP128_CONVERT(".insn rrf,0xb3e90000", cc_dep1,
+      return S390_CC_FOR_DFP128_CONVERT_ZOS("cgxtr", cc_dep1,
                                         cc_dep2, cc_ndep);
+      //return S390_CC_FOR_DFP128_CONVERT(".insn rrf,0xb3e90000", cc_dep1,
+        //                                cc_dep2, cc_ndep);
 
    case S390_CC_OP_DFP_64_TO_UINT_32: /* CLFDTR */
-      return S390_CC_FOR_DFP_UCONVERT(".insn rrf,0xb9430000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_DFP_UCONVERT("clfdtr", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_DFP_UCONVERT(".insn rrf,0xb9430000", cc_dep1, cc_dep2);
 
    case S390_CC_OP_DFP_128_TO_UINT_32: /* CLFXTR */
-      return S390_CC_FOR_DFP128_UCONVERT(".insn rrf,0xb94b0000", cc_dep1,
+      return S390_CC_FOR_DFP128_UCONVERT(" clfxtr", cc_dep1,
                                          cc_dep2, cc_ndep);
+      //return S390_CC_FOR_DFP128_UCONVERT(".insn rrf,0xb94b0000", cc_dep1,
+        //                                 cc_dep2, cc_ndep);
 
    case S390_CC_OP_DFP_64_TO_UINT_64: /* CLGDTR */
-      return S390_CC_FOR_DFP_UCONVERT(".insn rrf,0xb9420000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_DFP_UCONVERT(" clgdtr", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_DFP_UCONVERT(".insn rrf,0xb9420000", cc_dep1, cc_dep2);
 
    case S390_CC_OP_DFP_128_TO_UINT_64: /* CLGXTR */
-      return S390_CC_FOR_DFP128_UCONVERT(".insn rrf,0xb94a0000", cc_dep1,
+      return S390_CC_FOR_DFP128_UCONVERT("clgxtr", cc_dep1,
                                          cc_dep2, cc_ndep);
+     // return S390_CC_FOR_DFP128_UCONVERT(".insn rrf,0xb94a0000", cc_dep1,
+       //                                  cc_dep2, cc_ndep);
 
    case S390_CC_OP_PFPO_32: {
       __asm__ volatile(
-           "ldgr 4, %[cc_dep1]\n\t"     /* Load FR from GR */
-           "lr   0, %[cc_dep2]\n\t"     /* 32 bit GR move */
-           ".insn e,0x010a\n\t"         /* PFPO */
-           "ipm  %[psw]\n\t"            : [psw] "=d"(psw)
+           " ldgr 4,%[cc_dep1]\n\t"     /* Load FR from GR */
+           " lr   0,%[cc_dep2]\n\t"     /* 32 bit GR move */
+           //".insn e,0x010a\n\t"         /* PFPO */
+           " pfpo\n\t"         /* PFPO */
+           " ipm  %[psw]\n\t"            : [psw] "=d"(psw)
                                         : [cc_dep1] "d"(cc_dep1),
                                           [cc_dep2] "d"(cc_dep2)
                                         : "r0", "r1", "f4");
@@ -1726,10 +1980,11 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
 
    case S390_CC_OP_PFPO_64: {
       __asm__ volatile(
-           "ldgr 4, %[cc_dep1]\n\t"
-           "lr   0, %[cc_dep2]\n\t"     /* 32 bit register move */
-           ".insn e,0x010a\n\t"         /* PFPO */
-           "ipm  %[psw]\n\t"            : [psw] "=d"(psw)
+           " ldgr 4,%[cc_dep1]\n\t"
+           " lr   0,%[cc_dep2]\n\t"     /* 32 bit register move */
+           " pfpo\n\t"         /* PFPO */
+           //" .insn e,0x010a\n\t"         /* PFPO */
+           " ipm  %[psw]\n\t"            : [psw] "=d"(psw)
                                         : [cc_dep1] "d"(cc_dep1),
                                           [cc_dep2] "d"(cc_dep2)
                                         : "r0", "r1", "f4");
@@ -1738,11 +1993,12 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
 
    case S390_CC_OP_PFPO_128: {
       __asm__ volatile(
-           "ldgr 4,%[cc_dep1]\n\t"
-           "ldgr 6,%[cc_dep2]\n\t"
-           "lr   0,%[cc_ndep]\n\t"      /* 32 bit register move */
-           ".insn e,0x010a\n\t"         /* PFPO */
-           "ipm  %[psw]\n\t"             : [psw] "=d"(psw)
+           " ldgr 4,%[cc_dep1]\n\t"
+           " ldgr 6,%[cc_dep2]\n\t"
+           " lr   0,%[cc_ndep]\n\t"      /* 32 bit register move */
+           " pfpo\n\t"         /* PFPO */
+           //" .insn e,0x010a\n\t"         /* PFPO */
+           " ipm  %[psw]\n\t"             : [psw] "=d"(psw)
                                         : [cc_dep1] "d"(cc_dep1),
                                           [cc_dep2] "d"(cc_dep2),
                                           [cc_ndep] "d"(cc_ndep)
@@ -1751,10 +2007,12 @@ s390_calculate_cc(ULong cc_op, ULong cc_dep1, ULong cc_dep2, ULong cc_ndep)
    }
 
    case S390_CC_OP_MUL_32:
-      return S390_CC_FOR_TERNARY(".insn rrf,0xb9fd0000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_TERNARY(" msrkc", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_TERNARY(".insn rrf,0xb9fd0000", cc_dep1, cc_dep2);
 
    case S390_CC_OP_MUL_64:
-      return S390_CC_FOR_TERNARY(".insn rrf,0xb9ed0000", cc_dep1, cc_dep2);
+      return S390_CC_FOR_TERNARY(" msgrkc", cc_dep1, cc_dep2);
+      //return S390_CC_FOR_TERNARY(".insn rrf,0xb9ed0000", cc_dep1, cc_dep2);
 
    default:
       break;
@@ -1923,29 +2181,6 @@ guest_s390x_spechelper(const HChar *function_name, IRExpr **args,
             Because cc == 3 cannot occur the rightmost bit of cond is
             a don't care.
          */
-         if (isC64(cc_dep2)) {
-            /* Avoid memcheck false positives for comparisons like `<= 0x1f',
-               `> 0x1f', `< 0x20', or `>= 0x20', where the lower bits don't
-               matter.  Some compiler optimizations yield such comparisons when
-               testing if any (or none) of the upper bits are set. */
-
-            ULong mask = cc_dep2->Iex.Const.con->Ico.U64;
-            ULong c    = cond & (8 + 4 + 2);
-
-            if ((mask & (mask - 1)) == 0) {
-               /* Transform `<  0x20' to `<= 0x1f' and
-                            `>= 0x20' to `>  0x1f' */
-               mask -= 1;
-               c ^= 8;
-            }
-            if (mask != 0 && (mask + 1) != 0 && (mask & (mask + 1)) == 0 &&
-                (c == 8 + 4 || c == 2)) {
-               IROp cmp = c == 8 + 4 ? Iop_CmpEQ64 : Iop_CmpNE64;
-               return unop(Iop_1Uto32,
-                           binop(cmp, binop(Iop_And64, cc_dep1, mkU64(~mask)),
-                                 mkU64(0)));
-            }
-         }
          if (cond == 8 || cond == 8 + 1) {
             return unop(Iop_1Uto32, binop(Iop_CmpEQ64, cc_dep1, cc_dep2));
          }
@@ -2473,11 +2708,6 @@ s390x_dirtyhelper_vec_op(VexGuestS390XState *guest_state,
       [S390_VEC_OP_VFMAX] = {0xe7, 0xef},
       [S390_VEC_OP_VBPERM]= {0xe7, 0x85},
       [S390_VEC_OP_VMSL]  = {0xe7, 0xb8},
-      [S390_VEC_OP_VCNF]  = {0xe6, 0x55},
-      [S390_VEC_OP_VCLFNH]= {0xe6, 0x56},
-      [S390_VEC_OP_VCFN]  = {0xe6, 0x5d},
-      [S390_VEC_OP_VCLFNL]= {0xe6, 0x5e},
-      [S390_VEC_OP_VCRNF] = {0xe6, 0x75},
    };
 
    union {
@@ -2517,16 +2747,6 @@ s390x_dirtyhelper_vec_op(VexGuestS390XState *guest_state,
          UInt rxb : 4;
          UInt op2 : 8;
       } VRRc;
-      struct {
-         UInt op1 : 8;
-         UInt v1  : 4;
-         UInt v2  : 4;
-         UInt     : 12;
-         UInt m4  : 4;
-         UInt m3  : 4;
-         UInt rxb : 4;
-         UInt op2 : 8;
-      } VRRa;
       struct {
          UInt op1 : 8;
          UInt v1  : 4;
@@ -2582,7 +2802,6 @@ s390x_dirtyhelper_vec_op(VexGuestS390XState *guest_state,
    case S390_VEC_OP_VFMIN:
    case S390_VEC_OP_VFMAX:
    case S390_VEC_OP_VBPERM:
-   case S390_VEC_OP_VCRNF:
       the_insn.VRRc.v1 = 1;
       the_insn.VRRc.v2 = 2;
       the_insn.VRRc.v3 = 3;
@@ -2592,17 +2811,6 @@ s390x_dirtyhelper_vec_op(VexGuestS390XState *guest_state,
       the_insn.VRRc.m6 = d->m6;
       break;
 
-   case S390_VEC_OP_VCNF:
-   case S390_VEC_OP_VCLFNH:
-   case S390_VEC_OP_VCFN:
-   case S390_VEC_OP_VCLFNL:
-      the_insn.VRRa.v1 = 1;
-      the_insn.VRRa.v2 = 2;
-      the_insn.VRRa.rxb = 0b1100;
-      the_insn.VRRa.m3 = d->m3;
-      the_insn.VRRa.m4 = d->m4;
-      break;
-
    case S390_VEC_OP_VFTCI:
       the_insn.VRIe.v1 = 1;
       the_insn.VRIe.v2 = 2;
@@ -2619,33 +2827,32 @@ s390x_dirtyhelper_vec_op(VexGuestS390XState *guest_state,
 
    const V128* guest_v = &(guest_state->guest_v0);
    __asm__ volatile (
-      "lgr %%r10, %[arg1]\n"
-      VL(2, 0, a, 000, 8)
-      "lgr %%r10, %[arg2]\n"
-      VL(3, 0, a, 000, 8)
-      "lgr %%r10, %[arg3]\n"
-      VL(4, 0, a, 000, 8)
-      "ex %[zero], %[insn]\n"
-
-      "cijne %[read_only], 0, return_cc\n"
-      "lgr %%r10, %[res]\n"
-      VST(1, 0, a, 000, 8)
-
-      "return_cc: "
-      "ipm %[psw]\n\t"
-         : [psw] "=d" (psw)
-
-         : [res]  "r" (&guest_v[d->v1]),
-           [arg1] "r" (&guest_v[d->v2]),
-           [arg2] "r" (&guest_v[d->v3]),
-           [arg3] "r" (&guest_v[d->v4]),
-
-           [zero] "r" (0ULL),
-           [insn] "R" (the_insn),
-           [read_only] "r" (d->read_only)
-
-         : "cc", "r10", "v16", "v17", "v18", "v19"
-      );
+      " lgr 10,%[arg1]\n"
+      " vl 2,0(0,10)\n"
+      " lgr 10,%[arg2]\n"
+      " vl 3,0(0,10)\n"
+      " lgr 10,%[arg3]\n"
+      " vl 4,0(0,10)\n"
+      " ex %[zero],%[insn]\n"
+
+      " cgr %[read_only],0\n"
+      " lgr 10,%[res]\n"
+      " vst 1,0(0,10)\n"
+
+      " ipm %[psw]\n"
+      : [psw] "=d" (psw)
+
+      : [res]  "r" (&guest_v[d->v1]),
+        [arg1] "r" (&guest_v[d->v2]),
+        [arg2] "r" (&guest_v[d->v3]),
+        [arg3] "r" (&guest_v[d->v4]),
+
+        [zero] "r" (0ULL),
+        [insn] "R" (the_insn),
+        [read_only] "r" (d->read_only)
+
+      : "cc", "r10", "v16", "v17", "v18", "v19"
+    );
 
    return psw >> 28;   /* cc */
 }
@@ -2701,9 +2908,10 @@ s390x_dirtyhelper_PPNO_sha512(VexGuestS390XState *guest_state, ULong r1, ULong r
    register ULong reg5 asm("5") = op2[1];
 
    ULong cc = 0;
-   asm volatile(".insn rre, 0xb93c0000, %%r2, %%r4\n"
-                "ipm %[cc]\n"
-                "srl %[cc], 28\n"
+   //asm volatile(".insn rre, 0xb93c0000, 2, 4\n"
+   asm volatile(" prno 2,4\n"
+                " ipm %[cc]\n"
+                " srl %[cc],28\n"
                 : "+d"(reg0), "+d"(reg1),
                   "+d"(reg2), "+d"(reg3),
                   "+d"(reg4), "+d"(reg5),
